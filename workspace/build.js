
const PATH = require("path");
const FS = require("fs-extra");
const CRYPTO = require("crypto");
const ZLIB = require("zlib");
const COLORS = require("colors");
const CLOSURE_COMPILER = require('google-closure-compiler').jsCompiler;
const BROTLI = require("brotli");

const ROOT_PATH = PATH.dirname(__dirname);


exports.build = async function () {

	console.log(COLORS.yellow(`[build] Building files ...`));

	await exports.getMinifiedSource();
	
	console.log(COLORS.green(`[build] Built files successfully!`));
}

exports.getRawSource = function () {
	return FS.readFileSync(ROOT_PATH + "/loader.js", "utf8");
}

exports.getStrippedSource = function () {
	var source = exports.getRawSource();
	
	source = source.split("\n").filter(function(line) {
		return !(/\/\*DEBUG\*\//.test(line));
	}).join("\n");

	source = "\n\n// NOTE: DO NOT EDIT THIS FILE! IT IS AUTO-GENERATED FROM ./loader.js BY STRIPPING '/*DEBUG*/' LINES ON `make build`.\n\n\n" + source;

	FS.writeFileSync(ROOT_PATH + "/loader.stripped.js", source, "utf8");

	return source;
}

var minifying = false;
exports.getMinifiedSource = async function () {

	var source = exports.getStrippedSource();
	var sourceHash = CRYPTO.createHash("md5").update(source).digest("hex");
	var fileHash = false;
	
	if (FS.existsSync(ROOT_PATH + "/workspace/www/.loader.stripped.js.md5")) {
		fileHash = FS.readFileSync(ROOT_PATH + "/workspace/www/.loader.stripped.js.md5").toString();
	}

	if (sourceHash != fileHash && minifying === false) {
		minifying = true;

		console.log(COLORS.yellow(`[build] Minifying loader.js ...`));

		const minResult = await new Promise(function (resolve, reject) {
			const compilerProcess = new CLOSURE_COMPILER({
				compilation_level: 'ADVANCED'
			}).run([{
				src: source
			}], function (exitCode, result, stdErr) {
				if (!result) {
					console.error(COLORS.red(stdErr));
					return reject(new Error(`Closure Compiler failed with exit code: ${exitCode}`));
				}
				return resolve(result[0]);
			});
		});

		FS.writeFileSync(ROOT_PATH + "/loader.min.js", minResult.src, "utf8");
		FS.writeFileSync(ROOT_PATH + "/loader.min.js.map", minResult.sourceMap, "utf8");
		FS.writeFileSync(ROOT_PATH + "/workspace/www/.loader.min.js-size", ""+minResult.src.length, "utf8");

		const zipResult = await new Promise(function (resolve, reject) {
			return ZLIB.gzip(Buffer.from(minResult.src), function (err, result) {
				if (err) return reject(err);
				resolve(result);
			});
		});

		FS.writeFileSync(ROOT_PATH + "/loader.min.js.gz", zipResult);
		FS.writeFileSync(ROOT_PATH + "/workspace/www/.loader.min.js.gz-size", ""+zipResult.length, "utf8");

		const brotliResult = BROTLI.compress(Buffer.from(minResult.src));

		FS.writeFileSync(ROOT_PATH + "/loader.min.js.br", brotliResult);
		FS.writeFileSync(ROOT_PATH + "/workspace/www/.loader.min.js.br-size", ""+brotliResult.length, "utf8");

		var readme = FS.readFileSync(ROOT_PATH + "/README.md").toString();
		readme = readme.replace(/\*\*\d* bytes\*\* \*\(\.min\.br\)\*/, "**" + brotliResult.length + " bytes** *(.min.br)*");
		FS.writeFileSync(ROOT_PATH + "/README.md", readme, "utf8");

		FS.writeFileSync(ROOT_PATH + "/workspace/www/.loader.stripped.js.md5", sourceHash, "utf8");

		console.log(COLORS.green(`[build] Minified loader.js successfully!`));

		minifying = false;
	}

	return FS.readFileSync(ROOT_PATH + "/loader.min.js", "utf8");
}

if (require.main === module) {
    exports.build().catch(function (err) {
		console.error(err.stack);
		process.exit(1);
	});
}
