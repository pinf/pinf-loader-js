
const PATH = require("path");
const FS = require("fs-extra");
const CRYPTO = require("crypto");
const REQUEST = require("request");
const ZLIB = require("zlib");

const ROOT_PATH = PATH.dirname(__dirname);


exports.build = function(callback) {

	console.log("Building files ...");

	return exports.getMinifiedSource(function (err) {
		if (err) return callback(err);

		console.log("... Built files successfully!");

		return callback(null);
	});
}

exports.getRawSource = function () {
	return FS.readFileSync(ROOT_PATH + "/loader.js").toString();
}

exports.getStrippedSource = function () {
	var source = exports.getRawSource();
	
	source = source.split("\n").filter(function(line) {
		return !(/\/\*DEBUG\*\//.test(line));
	}).join("\n");

	source = "\n\n// NOTE: DO NOT EDIT THIS FILE! IT IS AUTO-GENERATED FROM ./loader.js BY STRIPPING '/*DEBUG*/' LINES ON `make build`.\n\n\n" + source;

	FS.writeFileSync(ROOT_PATH + "/loader.stripped.js", source);

	return source;
}

var minifying = false;
exports.getMinifiedSource = function (callback) {
	try {
		var source = exports.getStrippedSource();
		var sourceHash = md5Hash(source);
		var fileHash = false;

		function success() {
			return callback(null, FS.readFileSync(ROOT_PATH + "/loader.min.js").toString());		
		}
		
		if (FS.existsSync(ROOT_PATH + "/workspace/www/loader.stripped.js.md5")) {
			fileHash = FS.readFileSync(ROOT_PATH + "/workspace/www/loader.stripped.js.md5").toString();
		}

		if (sourceHash != fileHash && minifying === false) {
		    minifying = true;

		    console.log("Minifying loader.js using Google Closure ...");

			return compileSource(source, function(err, compiledSource) {
				if (err) return callback(err);

				FS.writeFileSync(ROOT_PATH + "/loader.min.js", compiledSource);
	            FS.writeFileSync(ROOT_PATH + "/workspace/www/loader.min.js-size", ""+compiledSource.length);

	            return writeZip(compiledSource, ROOT_PATH + "/loader.min.js.gz", function(err, result) {
	            	if (err) return callback(err);

	                FS.writeFileSync(ROOT_PATH + "/workspace/www/loader.min.js.gz-size", ""+result.length);

	                var readme = FS.readFileSync(ROOT_PATH + "/README.md").toString();
	                readme = readme.replace(/\*\*\d* bytes\*\* \*\(minified and zipped\)\*/, "**" + result.length + " bytes** *(minified and zipped)*");
	                FS.writeFileSync(ROOT_PATH + "/README.md", readme);

		            FS.writeFileSync(ROOT_PATH + "/workspace/www/loader.stripped.js.md5", sourceHash);
		            console.log("... OK");

		            minifying = false;

		            return success();
				});
			});
		}
		return success();
	} catch(err) {
		return callback(err);
	}
}

function md5Hash(data) {
    var shasum = CRYPTO.createHash("md5");
    shasum.update(data);
    return shasum.digest("hex");
}

function writeZip(source, zipPath, callback) {
    return ZLIB.gzip(new Buffer(source), function(err, result) {
    	if (err) return callback(err);
        FS.writeFileSync(zipPath, result.toString("binary"));
        var out = FS.createWriteStream(zipPath);
        out.on("close", function() {
            return callback(null, result);
        });
        out.end(result);
    });
}

function compileSource(codestring, callback) {

	var url = 'http://closure-compiler.appspot.com/compile';
	return REQUEST.post(url, {
		form: {
			'compilation_level' : 'SIMPLE_OPTIMIZATIONS',
			'output_format': 'json',
			'output_info': 'compiled_code',
			'js_code' : codestring
		}
	}, function (err, response, body) {
		if (err) return callback(err);
		if (response.statusCode !== 200) {
			return callback(new Error("Did not get response status 200 when posting to '" + url + "'"));
		}
		return callback(null, JSON.parse(body).compiledCode);
	});
}


if (require.main === module) {
    exports.build(function(err) {
    	if (err) {
    		console.error(err.stack);
    		process.exit(1);
    	}
    	process.exit(0);
    });
}
